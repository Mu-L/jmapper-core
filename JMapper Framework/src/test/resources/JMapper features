     
Versione 1.2.2 RILASCIATA:

 - aggiunta gestione errori dei metodi dinamici relativi:
   alla scrittura errata di metodi e al passaggio di variabili null
 - aggiunta gestione del setting dei primitivi in mapping complessi
 - aggiornate le dipendenze: xstream, slf4j e javassist
 - aggiunto printStackTrace oltre alla gestione con log 
 - in caso di creazione di collection in destination l'ordine degli elementi viene rispettato
 - aggiunta gestione get dei campi boolean
 - renderlo OSGI compatibile
 - gestito gli analyzer in un vettore e non con una sequenza di if.


Versione 1.3.0 RILASCIATA:
   
 - definizione dell xsd per content assist da eclipse
 - Possibilit‡† di definire get e set custom, vedi JMapAccessor file.

Versione 1.3.1 RILASCIATA:

 - aggiunta di class in JMapConversion per differenziare set/get del campo corrente da quello target nel 
   caso in cui abbiano lo stesso nome
 - permettere di omettere il set in caso di conversioni sia statiche che dinamiche e in tal caso di farlo void
   e quindi senza fare return. (ricordare nella documentazione che in static Ë possibile farlo void
   e in dynamic Ë possibile evitare il return sapendo che il viene ritornato un null.
 - gestire il passaggio da JMapAccessor al relativo xml e viceversa   
 
Versione 1.3.2 RILASCIATA:

 - permettere di utilizzare nelle conversioni dinamiche i get e set sia custom che no
   i placeholder saranno: ${*.get} e ${*.set} dove * sta per destination o source

Versione 1.3.3 RILASCIATA:

 - permettere l'uso dei regex nella definizione dei nomi 
 
Versione 1.3.3.1 RILASCIATA:

 - fix di 3 bug
   
 -----------------------------------------------------------------------------------------  
     Sviluppo componenti esterni come procedere ?     
     Integrazione con Hibernate, Apache Camel, XMLBeans, JAXB
     eclipse plugin
 
  Sviluppo di configurazione tramite API ? 
  	 Creare delle fluent API che permettono di costruire il file xml.
  	 Utilizzare le classi configurate con XSTREAM in modo da chiamare il toString() sul nodo root per avere
  	 l'xml completo.
  	 es:
  	 new JMapperAPI().
		addClass(NomeClasse.class).
			addGlobal(""). // con e senza stringa per il value
			    addAttributes().
			       addAttribute("name","get","set",Class<?>).
			toGlobal().
				addExcluded().
				    addAttribute("name","get","set",Class<?>).
			toGlobal().
		toClass().
			addAttribute().
			addAttribute(campi).
				addTargetAttribute().
				
			addConversion().
			addConversion(campi).
				body().
		toRoot().
		toString();
  	 
  	 Ritornando una stringa si da la possibilit‡ di utilizzare altri tool per la definizione
  	 dell'xml ad esempio:
  	    dom4j - http://dom4j.sourceforge.net/dom4j-1.6.1/index.html
  	    mycila - http://code.mycila.com/xmltool/
  	    

   

    
Versione 1.4.0 

 - interfacciare JMapper per funzionare con javassist, janino e bytebuddy (di default usare bytebuddy o janino)

Versione 1.5.0

 - permettere funzioni di projection e flatten
 
2.0.0

 - Multiple Mapping
   
  - Con la classe RelationalJMapper si ha la possibilit‡† di implementare una relazione 1 a N o N a 1 tra
    la classe configurata e quelle target.
    Ma la relazione che c'Ë tra i campi della classe configurata e i campi delle classi target Ë sempre 1 a 1 (con @JMap).
    CiÚ vuol dire che in caso di conversioni dinamiche non Ë permesso configurare 
    direttamente un campo con N altri, ma invece bisogna configurare gli N campi verso il campo interessato.
    Con la versione 1.2.0 Ë possibile (tramite JGlobalMap) mappare N campi verso uno.
    CiÚ che manca Ë la possibilit√† di mappare un campo verso N.

    Obiettivo
   
      L'intento Ë quello di configurare 1 campo verso N altri:
           
      ANNOTATION
           
       	class Esempio {
           
               @JMultiMap(targetClass=Target.class,attributes={"field1","field2","field3"}) 
               String field1;
               ...
           }
           
           @JMultiMap permette di configurare un campo contemporaneamente con N altri. Omettendo la targetClass si indica
           al framework di considerare quella in input al costruttore, omettendo gli attributes si indica al framework che
           tutti i campi della classe target sono coinvolti.
           Nel caso in cui ci sia l'esigenza di dichiarare il multimapping verso altri campi di altre classi baster√†
           usare piu volte l'annotation @JMultiMap es:
           
       	class Esempio {
           
               @JMultiMap(targetClass=Target.class,attributes={"field1","field2","field3"})
               @JMultiMap(targetClass=Other.class, attributes={"other1","other2","other3"})
               String field1;
               ...
           }
           
      XML
           
           Per esprimere lo stesso concetto in xml si utilizzer‡† il nodo multiAttribute, es:
           
  	 <multiAttribute name="field1">
     	      <target class="com.myapplication.Target" attributes="field1,field2,field3" />
  	 </multiAttribute>
  
           multiAttribute ha un attributo name che corrisponde al nome del campo configurato e N nodi target,
           il nodo target rispecchia l'annotation @JMultiMap, ovvero ha un attributo class e un attributo attributes,
           che contiene la lista dei campi separati da una virgola.
           Per riflettere invece JMultiMaps baster√† dichiarare piu nodi target. 

2.1.0

   - aggiunta dell'annotation @JMapPlaceHolder(key="",value="") sui campi e classe.
    questo permetter‡† in fase di conversione DINAMICA di utilizzare i placeholder per funzioni particolari come:

	conversione da resulSet a bean: resultSet.getString(${destination.placeholder.field.key})
	
	(destination/source).placeholder.(global/field).(nome della chiave)
	
	in XML: 
		<attribute>
			<placeholders>
				<placeholder key="" value=""/>
			</placeholders>
		</attribute>
		
		oppure in global:
		<global>
			<placeholders>
				<placeholder key="" value=""/>
			</placeholders>
		</global>
	
	- Prevedere una classe custom che permetta il mapping rapido di strutture dati con bean.
  	In questo modo si da la possibilit√† di mappare una HashMap, resultSet, properties con un bean e viceversa 

	i placeholder su global sono intesi come generici a tutti i campi

2.2.0
- possibilit‡† di definire configurazioni xml generiche senza creare classi (template):
    
	Possibilit‡† di definire N template sia in Annotation che in XML sulla stessa classe.
	In modo da mappare un sotto insieme di campi del bean stesso per volta.
	ad esempio:
		bean con 4 campi: 2 campi con template1 e gli altri due col template2
		e permettere la stessa funzionalit‡† con l'annotation @JsonView per utilizzare il templating
		

	
4.0.0

 - DEFAULT BEHAVIORs
  
   i comportamenti predefiniti tornano utili in tutti quei casi in cui il mapping Ë preferibile 
   applicarlo al "tipo" piuttosto che al "nome" del campo. 
   Ad essere analizzati quindi sono i tipi dei campi, non servir√† quindi dichiarare i nomi dei campi interessati.
   Un esempio pu√≤ essere la conversione da String a Date:

   @DefaultBehavior
   class DateBehaviors {
   
      @Creation
      public static Date getDate(String str){
         return new java.text.SimpleDateFormat("dd/MM/yyyy").parse(str);
      }
      
      @Enrichment
      public static void enrichDate(Date date, String str){
         date = new java.text.SimpleDateFormat("dd/MM/yyyy").parse(str);
      }
   }
   
   Oppure quando il campo di destinazione √® una lista e i campi sorgenti sono oggetti: in questo caso il 
   comportamento predefinito consisterebbe nel effettuare diversi add.
   
   @DefaultBehavior
   class ListBehaviors {
   
      @Creation
      public static <T> List<T> getList(T str){
         List<T> list = new ArrayList<T>();
         list.add(str);
         return list;
      }
  
      @Enrichment
      public static <T> void enrichList(List<T> list, T str){
         list.add(str);
      }
   }
  
   Lo stesso criterio lo si pu√≤ usare quando ad essere configurati sono un StringBuilder/StringBuffer con diverse stringhe.
  
   @DefaultBehaviors
   class ListBehaviors {
   
      @Creation
      public static StringBuilder getSb(Object obj){
        return new StringBuilder(obj);
      }
      
      @Enrichment
      public static void enrichSb(StringBuilder sb, Object str){
         sb.append(obj);
      }
   }
  
   IMPORTANTE Le conversioni esplicite hanno la precedenza.
   
   Per usufruire di questa feature bisogna contrassegnare la classe con l'annotation @DefaultBehavior
   e contrassegnare i metodi che creano il destination con @Creation e quelli che lo arricchiscono con @Enrichment
   √® possibile aggiungere infiniti metodi. con qualsiasi tipo di input ed output, ad essere valutati saranno i tipi di input e
   output dei metodi.
  